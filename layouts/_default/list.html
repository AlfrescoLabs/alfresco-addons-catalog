{{ define "main" }}

{{ partial "hero.html" . }}
<div id="catalog-hero-toggle" class="catalog-hero-toggle">
  <a href="#">About this Catalog</a>
</div>

<div class="layout">
  <aside class="sidebar">
    <div id="facet-root">
      <div class="facet-block">
        <h4>License</h4>
        <div id="facet-license"></div>
      </div>
      <div class="facet-block">
        <h4>Compatibility</h4>
        <div id="facet-compat"></div>
      </div>
      <div class="facet-block">
        <h4>Keywords</h4>
        <div id="facet-keywords"></div>
      </div>
      <button id="facet-clear" class="btn-clear" type="button">Clear filters</button>
    </div>
  </aside>

  <section class="results">
    <div class="searchbar">
      <div class="input">
        <input id="q" type="search" placeholder="Search solutions, vendors, keywords..." aria-label="Search"/>
      </div>
      <div class="facet">
        <span>Sort</span>
        <select id="sort">
          <option value="relevance">Relevance</option>
          <option value="az">A to Z</option>
          <option value="za">Z to A</option>
          <option value="newest">Newest</option>
        </select>
      </div>
    </div>

    <!-- Visual grid (server paginated for no-JS users).
         When JS is active, we will fully control its contents from index.json -->
    <section class="grid" id="cards">
      {{/* Paginate the entries section */}}
      {{ $all := where .Site.RegularPages "Section" "entries" }}
      {{ $p := .Paginate $all }}
      {{ range $p.Pages }}
        {{ partial "card.html" . }}
      {{ end }}
    </section>

    <!-- Server-side pagination controls (good for SEO & no-JS users).
         JS-powered filtering will ignore this, but we keep it for progressive enhancement. -->
    <nav class="pagination">
      {{ template "_internal/pagination.html" . }}
    </nav>
  </section>
</div>

<script src="https://cdn.jsdelivr.net/npm/fuse.js@6.6.2"></script>
<script>
(async function () {
  // Base URL to entry pages (e.g., "/entries/")
  const baseEntries = '{{ "entries/" | relURL }}';

  // Load the full index (ALL entries, not paginated)
  const res = await fetch('{{ "index.json" | relURL }}');
  const data = await res.json();

  // Fuse for relevance
  const fuse = new Fuse(data, {
    keys: ['title','vendor','keywords','description','compatibility','license'],
    threshold: 0.3
  });

  // Elements
  const q     = document.getElementById('q');
  const sort  = document.getElementById('sort');
  const grid  = document.getElementById('cards');

  // Facet containers
  const fx = {
    license:  document.getElementById('facet-license'),
    compat:   document.getElementById('facet-compat'),
    keywords: document.getElementById('facet-keywords'),
    clearBtn: document.getElementById('facet-clear'),
  };

  // Helpers
  const uniq  = (arr) => [...new Set(arr)].filter(Boolean).sort();
  const flat  = (arr) => arr.flat ? arr.flat() : [].concat.apply([], arr);

  // Precompute facet values
  const values = {
    license:  uniq(data.map(x => x.license)),
    compat:   uniq(flat(data.map(x => x.compatibility || []))),
    keywords: uniq(flat(data.map(x => x.keywords || []))),
  };

  // Facet rendering
  function renderFacet(root, items, counts, facetKey) {
    root.innerHTML = '';
    items.forEach(v => {
      const id  = encodeURIComponent(v);
      const cnt = counts[v] || 0;
      const lab = document.createElement('label');
      lab.className = 'facet-item';
      lab.innerHTML = `
        <input type="checkbox" value="${id}">
        <span>${v}</span>
        <em>${cnt}</em>
      `;
      root.appendChild(lab);
    });
    root.addEventListener('change', apply);
  }

  function countsFor(list, key, arrayField) {
    const m = {};
    list.forEach(x => {
      const val = x[key];
      if (arrayField) {
        (val || []).forEach(v => { m[v] = (m[v] || 0) + 1; });
      } else if (val) {
        m[val] = (m[val] || 0) + 1;
      }
    });
    return m;
  }

  renderFacet(fx.license,  values.license,  countsFor(data,'license',false),       'license');
  renderFacet(fx.compat,   values.compat,   countsFor(data,'compatibility',true),  'compat');
  renderFacet(fx.keywords, values.keywords, countsFor(data,'keywords',true),       'keywords');

  // State
  const selected = { license:new Set(), compat:new Set(), keywords:new Set() };

  function getFilters(){
    const pick = (root) => [...root.querySelectorAll('input[type="checkbox"]:checked')].map(x => decodeURIComponent(x.value));
    return {
      text:     q.value.trim(),
      license:  pick(fx.license),
      compat:   pick(fx.compat),
      keywords: pick(fx.keywords),
      sort:     sort.value || 'relevance',
    };
  }

  // Create a card element from index item
  function renderCard(item) {
    const a = document.createElement('article');
    a.className = 'card';
    a.setAttribute('data-slug', item.slug);
    const compat = (item.compatibility && item.compatibility.length) ? `Compat: ${item.compatibility.join(', ')}` : '';
    const license = item.license ? `License: ${item.license}` : '';
    const link = baseEntries + item.slug + '/';
    const dl   = item.download_url ? `<a href="${item.download_url}" target="_blank" rel="noopener">Download</a>` : '';
    a.innerHTML = `
      <h3><a href="${link}">${item.title}</a></h3>
      <p class="vendor">by ${item.vendor || ''}</p>
      <p class="desc">${item.description || ''}</p>
      <div class="badges">
        ${compat ? `<span class="badge">${compat}</span>` : ''}
        ${license ? `<span class="badge badge--muted">${license}</span>` : ''}
      </div>
      <div class="links">${dl}</div>
    `;
    return a;
  }

  function apply(){
    const f = getFilters();

    // Base list
    let list = data.slice();

    // Text query via Fuse
    let scoreMap = null;
    if (f.text) {
      const fuseResults = fuse.search(f.text);
      scoreMap = new Map(fuseResults.map(r => [r.item.slug, r.score]));
      list = fuseResults.map(r => r.item);
    }

    // Facets
    if (f.license.length)  list = list.filter(x => x.license && f.license.includes(x.license));
    if (f.compat.length)   list = list.filter(x => (x.compatibility || []).some(v => f.compat.includes(v)));
    if (f.keywords.length) list = list.filter(x => (x.keywords || []).some(v => f.keywords.includes(v)));

    // Sort
    if (f.sort === 'az')       list.sort((a,b) => a.title.localeCompare(b.title));
    else if (f.sort === 'za')  list.sort((a,b) => b.title.localeCompare(a.title));
    else if (f.sort === 'newest') list.sort((a,b) => (b.date||0) - (a.date||0));
    else if (f.sort === 'relevance' && scoreMap) list.sort((a,b) => (scoreMap.get(a.slug)||0) - (scoreMap.get(b.slug)||0));

    // Render results (client-side replaces paginated server list)
    grid.innerHTML = '';
    list.forEach(item => grid.appendChild(renderCard(item)));
  }

  // Clear facets
  fx.clearBtn.addEventListener('click', () => {
    [fx.license, fx.compat, fx.keywords].forEach(root => {
      root.querySelectorAll('input[type="checkbox"]').forEach(cb => { cb.checked = false; });
    });
    q.value = '';
    sort.value = 'newest';
    apply();
  });

  // Listeners
  q.addEventListener('input', apply);
  q.addEventListener('keyup', e => { if (e.key === 'Enter') apply(); });
  sort.addEventListener('change', apply);

  if (!sort.value) sort.value = 'newest';
  apply();
})();
</script>
{{ end }}
